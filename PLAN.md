# Implementation Plan: Issue #15 - Initiate Mint Feature

## Overview

This plan implements the Initiate mint feature for the mint flow, enabling the
issuance bot to receive and validate mint requests from Alpaca. The
implementation follows the ES/CQRS architecture already established in the
codebase.

## Design Decisions

### Aggregate State Modeling

The Mint aggregate will use an enum to model different lifecycle states,
following the "make invalid states unrepresentable" principle:

```rust
enum Mint {
    Uninitialized,
    Initiated {
        issuer_request_id: IssuerRequestId,
        tokenization_request_id: TokenizationRequestId,
        qty: Quantity,
        underlying: UnderlyingSymbol,
        token: TokenSymbol,
        network: Network,
        client_id: ClientId,
        wallet: Address,
        initiated_at: DateTime<Utc>,
    },
}
```

This approach ensures that:

- We cannot have a mint with missing required fields
- The type system enforces that initiated mints have all necessary data
- Pattern matching makes state transitions explicit and safe

### View Modeling

The MintView will mirror the aggregate states but use query-oriented naming:

```rust
enum MintView {
    NotFound,     // Mint not found in view
    Initiated {   // Mint has been initiated, waiting for journal
        // ... same fields as aggregate
    },
}
```

For this feature (InitiateMint only), we only need these two states. Future
features will extend this with additional states (JournalConfirmed, Minting,
etc.).

### Validation Strategy

Validation will occur in the endpoint handler BEFORE executing the command:

1. Check that the asset exists and is enabled (query TokenizedAssetView)
2. Check that the client_id exists and is active (query AccountView)
3. Validate qty is positive and reasonable
4. Validate wallet address format (Ethereum address)
5. Validate network matches expected value

If validation fails, return appropriate HTTP error codes without executing the
command.

### Aggregate ID Selection

We'll use the `issuer_request_id` as the aggregate ID since:

- It's unique per mint operation
- It's generated by us, not Alpaca
- It's what we return to Alpaca and use for all subsequent operations

### IssuerRequestId Generation

Use UUID v4 for generating issuer_request_ids to ensure uniqueness and avoid
collisions.

---

## Task 1. Create Mint Domain Types

Add newtypes and domain types to `src/mint/mod.rs` following the pattern
established in account and tokenized_asset modules.

- [x] Move existing types from mod.rs to proper locations
- [x] Add ClientId newtype (import from account module)
- [x] Add UnderlyingSymbol, TokenSymbol, Network newtypes (import from
      tokenized_asset module)
- [x] Add Address type from alloy
- [x] Ensure all types have proper Serialize/Deserialize derives

---

## Task 2. Implement Initiate Command

Create `src/mint/cmd.rs` with the command enum.

- [x] Create MintCommand::Initiate with all required fields
- [x] Use newtype wrappers for type safety
- [x] Add Serialize/Deserialize derives
- [x] Export from mod.rs

---

## Task 3. Implement Initiated Event

Create `src/mint/event.rs` with the event enum and DomainEvent implementation.

- [x] Create MintEvent enum with Initiated variant
- [x] Include all fields from the Initiate command plus generated
      issuer_request_id
- [x] Implement DomainEvent trait with event_type() returning
      "MintEvent::Initiated"
- [x] Set event_version() to "1.0"
- [x] Add Serialize/Deserialize derives
- [x] Export from mod.rs

---

## Task 4. Implement Mint Aggregate

Add the Mint aggregate to `src/mint/mod.rs` with handle() and apply() methods.

- [x] Define Mint enum with Uninitialized and Initiated states
- [x] Implement Default trait returning Uninitialized
- [x] Implement Aggregate trait with:
  - [x] Associated types (Command, Event, Error, Services)
  - [x] aggregate_type() returning "Mint"
  - [x] handle() method for MintCommand::Initiate
    - [x] Check state is Uninitialized
    - [x] Generate issuer_request_id using UUID v4
    - [x] Return vec![MintEvent::Initiated]
  - [x] apply() method for MintEvent::Initiated
    - [x] Transition from Uninitialized to Initiated state
- [x] Define MintError enum with appropriate error variants
- [x] Add comprehensive aggregate tests using TestFramework
- [x] Refactor qty â†’ quantity throughout mint module

---

## Task 5. Create Database Migration

Create migration for mint_view table following the established pattern.

- [x] Run `sqlx migrate add create_mint_view`
- [x] Add CREATE TABLE statement with view_id, version, payload columns
- [x] Add indexes for common query patterns:
  - [x] Index on client_id (extracted from JSON)
  - [x] Index on underlying symbol (extracted from JSON)
  - [x] Index on tokenization_request_id (extracted from JSON)

---

## Task 6. Implement MintView

Create `src/mint/view.rs` with the view struct and View trait implementation.

- [x] Define MintView enum mirroring aggregate states
- [x] Implement Default trait returning Unavailable
- [x] Implement View&lt;Mint&gt; trait with update() method
- [x] Add helper query functions:
  - [x] find_by_issuer_request_id() for querying specific mints
- [x] Add view update tests
- [x] Export from mod.rs

---

## Task 7. Update API Layer

Update `src/mint/api.rs` to connect the endpoint to the CQRS framework.

- [ ] Add complete request DTO matching Alpaca's API spec:
  - [ ] tokenization_request_id
  - [ ] qty
  - [ ] underlying_symbol (renamed to underlying in domain)
  - [ ] token_symbol (renamed to token in domain)
  - [ ] network
  - [ ] client_id
  - [ ] wallet_address (renamed to wallet in domain)
- [ ] Implement validation logic:
  - [ ] Query TokenizedAssetView to verify asset exists and enabled
  - [ ] Query AccountView to verify client_id exists and active
  - [ ] Validate qty is positive
  - [ ] Validate wallet is valid Ethereum address
  - [ ] Validate network matches expected value (e.g., "base")
  - [ ] Return 400 with appropriate error message if validation fails
- [ ] Execute MintCommand::Initiate via CQRS framework
- [ ] Query MintView to get created mint
- [ ] Return response with issuer_request_id and status "created"
- [ ] Update response DTO to match Alpaca's expected format
- [ ] Add proper error handling with appropriate HTTP status codes:
  - [ ] 200 for success
  - [ ] 400 for validation failures with specific error messages
  - [ ] 500 for internal errors

---

## Task 8. Wire CQRS Framework

Update `src/main.rs` to wire up the Mint aggregate with the CQRS framework.

- [ ] Import Mint and MintView types
- [ ] Create SqliteViewRepository for MintView
- [ ] Create GenericQuery wrapping the view repository
- [ ] Create MintCqrs using sqlite_cqrs()
- [ ] Add MintCqrs to Rocket state management
- [ ] Ensure migration runs on startup

---

## Task 9. Add Integration Tests

Add comprehensive tests to `src/mint/api.rs`.

- [ ] Test successful mint initiation returns issuer_request_id
- [ ] Test validation failures:
  - [ ] Invalid/unsupported asset returns 400
  - [ ] Unknown client_id returns 400
  - [ ] Negative quantity returns 400
  - [ ] Invalid wallet address returns 400
  - [ ] Wrong network returns 400
- [ ] Test events are persisted correctly in event store
- [ ] Test views are updated correctly
- [ ] Test duplicate tokenization_request_id handling
- [ ] Follow existing test patterns from account/api.rs

---

## Task 10. Add Unit Tests

Ensure comprehensive unit test coverage for all components.

- [ ] Aggregate tests in mod.rs:
  - [ ] MintCommand::Initiate creates MintEvent::Initiated
  - [ ] Apply MintEvent::Initiated transitions state correctly
  - [ ] Cannot initiate already-initiated mint
- [ ] View tests in view.rs:
  - [ ] Update from MintEvent::Initiated works correctly
  - [ ] Query functions return correct results
- [ ] Follow Given-When-Then pattern from existing tests

---

## Task 11. Run Quality Checks

Ensure all code quality checks pass before submitting.

- [ ] Run `cargo test --workspace` - all tests pass
- [ ] Run
      `cargo clippy --workspace --all-targets --all-features -- -D clippy::all -D warnings` -
      no warnings
- [ ] Run `cargo fmt` - code is formatted
- [ ] Manual testing with curl/httpie to verify endpoint works correctly

---

## Notes

### API Request/Response Format

Following SPEC.md section 3.1 (Step 1):

**Request:**

```json
{
  "tokenization_request_id": "12345-678-90AB",
  "qty": "1.23",
  "underlying_symbol": "TSLA",
  "token_symbol": "TSLAx",
  "network": "solana",
  "client_id": "98765432",
  "wallet_address": "0x..."
}
```

**Response:**

```json
{
  "issuer_request_id": "123-456-ABCD-7890",
  "status": "created"
}
```

### Validation Error Messages

From SPEC.md, use these exact error messages:

- "Invalid Wallet: Wallet does not belong to client"
- "Invalid Token: Token not available on the network"
- "Insufficient Eligibility: Client not eligible"
- "Failed Validation: Invalid data payload"

### Type Sharing

Some types are shared across modules:

- ClientId from account module
- UnderlyingSymbol, TokenSymbol, Network from tokenized_asset module
- Consider moving shared types to a common location if needed

### Future Extensions

This plan only implements the Initiate command (the first command in the mint
lifecycle). Future issues will add:

- ConfirmJournal command and events
- On-chain minting integration
- Callback to Alpaca
- Additional view states and transitions
